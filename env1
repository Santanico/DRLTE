/*
Simulation environment for DRL-TE
V1.0
Time:2018/6/12
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/time.h>
#include <cassert>
#include <numeric>
#include <math.h>
#include <python3.5m/Python.h>
#include "ns3/socket-factory.h"
#include "ns3/tcp-socket-factory.h"
#include "ns3/simulator.h"
#include "ns3/simple-channel.h"
#include "ns3/simple-net-device.h"
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/applications-module.h"
#include "ns3/csma-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/ipv4-static-routing-helper.h"
#include "ns3/ipv4-list-routing-helper.h"
#include "ns3/log.h"
#include "ns3/config-store-module.h"
#include "ns3/traffic-control-module.h"
#include "ns3/queue.h"
#include "ns3/drop-tail-queue.h"
#include "ns3/ipv4-address.h"
#include "ns3/double.h"
#include "ns3/config.h"
#include "ns3/config-store-module.h"
#include "ns3/traffic-control-module.h"

using namespace ns3;
using namespace std;

NS_LOG_COMPONENT_DEFINE ("SocketBoundUdpRoutingExample");

typedef pair<int, int> Edge;
bool printEnable=true;
bool printEnable2=false;//recvCallback

class DrlRouting
{
public:

  DrlRouting();
  ~DrlRouting();

  void init();
  void addPathsFromFile();
  void addPath(vector<int> path, double ratio_);
  void initNodes();
  void initPaths();
  void initAddrs();
  void initRoute();
  void initSinks();
  
  void begin();
  void randSendData(int iSession, uint8_t *data , int size);
  void update();
  void update(vector<vector<int>> pacNos, vector<vector<double>> dels, vector<vector<double>> thrs);
  void saveToFile(vector<vector<int>> pacNos, vector<vector<double>> dels, vector<vector<double>> thrs);

  void setSendRate(vector<string> rates);
  void setCap(string rate);
  void setUpTime(int time);
  void setStopTime(int time);
  void setPacketSize(int size);
  void setInputPath(string path);
  void setOutputPath(string path);
  void setErrp(double err);
  void setPrintEnable(bool printEn);
  void randRatio();
  void meanRatio();
  int spsToEdge(int sess, int path, int step);
  int spsDir(int sess, int path, int step);
  int spsSrc(int sess, int path, int step);
  int spsEnd(int sess, int path, int step);
  string getAddr(unsigned int addr);

private:
  double err_p;
  bool printEnable;
  double thrSum;
  double delSum;
  int upNum;
  string addrBase;
  string inputPath;
  string outputPath;
  int packetSize;
  int port;
  int nodeNum;
  int pathNum;
  int sessionNum;
  double stopTime;
  double pacSendSpeed;
  double lastSec;
  int maxDataSize;
  int minDataSize;
  double offTime;
  double upTime;
  uint8_t *data;

  //PyObject *pName;
  //PyObject *pModule;
  //PyObject *pFunc;

  DataRate cap;
  vector<DataRate> sendRates;
  vector< vector< vector<int> > > sPaths;
  vector< vector< vector<int> > > ePaths;
  vector< vector<double> > sRatios;

  NodeContainer nodes;
  InternetStackHelper internet;
  PointToPointHelper p2p;
  vector<Edge> edges;
  vector<NetDeviceContainer> spDevices;
  Ptr<RateErrorModel> errModel;
  
  Ipv4AddressHelper ipv4;
  Ipv4StaticRoutingHelper srHelper;
  vector< Ptr<Ipv4StaticRouting> > srNodes;
  vector<Ipv4InterfaceContainer> address;
  
  vector< vector< Ptr<Socket> > > srcsSocks;
  vector< vector< Ptr<Socket> > > endsSocks;
  vector< vector< Ptr<NetDevice> > > endsDevs;
  vector< vector< Ptr<NetDevice> > > srcsDevs;
  vector<ApplicationContainer> sinkApps;
};

class myTag : public Tag
{
public:
  static TypeId GetTypeId(void);
  virtual TypeId GetInstanceTypeId(void) const;
  virtual uint32_t GetSerializedSize(void) const;
  virtual void Serialize(TagBuffer i) const;
  virtual void Deserialize(TagBuffer i);
  virtual void Print(std::ostream &os) const;
  void SetValue1(double value);
  double GetValue1();
  void SetValue2(double value);
  double GetValue2();
private:
  double tagValue1;
  double tagValue2;
};


double getRand();
int getRand(vector<double> ratio);
int indexOf(vector<Edge> container, Edge value);
string doubleToString(double d);
void UdpSend(Ptr<Socket> sock, Ptr<Packet> packet, int sess, int path);
void recvCallback(Ptr<Socket> socket);

//-----< main function >-----
int main(int argc, char *argv[])
{
  string inputPath("/home/gn/geng/DRLTE/input.txt");
  string outputPath("/home/gn/geng/DRLTE/ouput.txt");
  string envPath("/home/gn/geng/drl_te/agent/");//python environment?????

  int upTime=500;//ms
  int stopTime=7;//s
  int packetSize=1024;
  double err_p=0.00000;//?????????????????0
  uint32_t seed=1;//hear is OK??

  CommandLine cmd;
  cmd.AddValue ("inputpath", "the path of file containing path information", inputPath);
  cmd.AddValue ("outputpath", "the file contains the lab result", outputPath);
  cmd.AddValue ("envpath", "the path of $PYTHONPATH", envPath);
  cmd.AddValue ("uptime", "update interval time", upTime);
  cmd.AddValue ("stoptime", "stop time, seconds", stopTime);
  cmd.AddValue ("packetsize", "KB", packetSize);
  cmd.AddValue ("seed", "random seed", seed);
  cmd.Parse(argc, argv);

  Config::SetDefault ("ns3::Queue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
  Config::SetDefault ("ns3::Queue::MaxPackets", UintegerValue(1000));
  Config::SetDefault("ns3::UdpSocket::RcvBufSize", UintegerValue(100000000));
  //setenv("PYTHONPATH" , ("$PYTHONPATH:"+envPath).c_str(), 1);//1 means overwrite

  SeedManager::SetSeed(seed);
  SeedManager::SetRun(seed);

//----------------------------------------------------------------
  cout<<"printEnable:"<<printEnable<<endl;
  DrlRouting drl=DrlRouting();
  drl.setErrp(err_p);
  drl.setPrintEnable(printEnable);
  drl.setInputPath(inputPath);
  drl.setOutputPath(outputPath);
  drl.setUpTime(upTime);
  drl.setStopTime(stopTime);
  drl.setPacketSize(packetSize);
  drl.init();
  Simulator::Schedule(Seconds(5.0), &DrlRouting::begin, &drl);//begin after 5 seconds
//---------------------------------------------------------------- 
  LogComponentEnableAll (LOG_PREFIX_TIME);
  LogComponentEnable ("SocketBoundUdpRoutingExample", LOG_LEVEL_INFO);

  Simulator::Run();
  Simulator::Destroy();
  return 0;
}

DrlRouting::DrlRouting()
{
  err_p=0.0;
  printEnable=false;
  thrSum=0;//total throughput
  delSum=0;//total delay
  upNum=0;//number of scheduling
  addrBase="0.0.0.0";//used to generate IPs for interfaces
  inputPath="";//the filepath of file for paths
  outputPath="";//the filepath of the file for plot
  packetSize=1024;
  port=12345;
  nodeNum=0;
  pathNum=0;
  sessionNum=0;
  this->stopTime=100;//stop time of this simulation
  this->pacSendSpeed=pacSendSpeed;
  lastSec=0;
  this->maxDataSize=75000000;  //the maximum data size
  this->minDataSize=50000000;  //the minimum data size
  this->offTime=0;//interval of sending when switching from existing data block to a new one; this variable is not very important
  this->upTime=500;//interval between two adjacent updates, i.e. schedulings
  data=new uint8_t[maxDataSize];//new a data block

  /*
  Py_Initialize();
  pName=PyUnicode_DecodeFSDefault("sim-ddpg");
  pModule = PyImport_Import(pName);
  Py_DECREF(pName);//quote counter
  const char * tmp = "step";
  pFunc = PyObject_GetAttrString(pModule, tmp);*/
}

DrlRouting::~DrlRouting()
{
  delete []data;
  data = NULL;
  std::cout<<"Memory is freed!"<<endl;
}

/*tool functions:*/
int DrlRouting::spsToEdge(int sess, int path, int step)
{
  int temp=ePaths[sess][path][step];
  if(temp>=0) return temp-1;
  return -temp-1;
}

int DrlRouting::spsDir(int sess, int path, int step)
{
  int temp=ePaths[sess][path][step];
  if(temp>=0) return 1;
  return -1;
}

int DrlRouting::spsSrc(int sess, int path, int step)
{
  int temp=ePaths[sess][path][step];
  if(temp>=0) return 1;
  return 2;
}

int DrlRouting::spsEnd(int sess, int path, int step)
{
  int temp=ePaths[sess][path][step];
  if(temp>=0) return 2;
  return 1;
}

string DrlRouting::getAddr(unsigned int addr)
{
  std::ostringstream subset;
  unsigned int i = addr;
  if (i < 255) {
    subset << "10.0." << i + 1 << ".0";
  }
  else {
    subset << "10." << int(i/255) << "." << i - int(i / 255)*255 + 1 << ".0";
  }
  return subset.str();
}

double getRand()
{
  double f;
  f = (float)(rand() % 100);
  return f/100;
}
int getRand(vector<double> ratio)
{
  int max=100;
  int len=ratio.size();
  vector<double> sec;
  double next=0.0;
  sec.push_back(next);
  for(int i=0; i<len-1; i++){
    next=next+ratio[i];
    sec.push_back(next*max);
  }
  sec.push_back(max);
  int res=rand()%(max+1);
  for(int i=0; i<len; i++){
    if(res>=sec[i] && res<=sec[i+1]) return i;
  }
  return -1;
}
int indexOf(vector<Edge> container, Edge value)
{
  for(unsigned int i=0; i<container.size(); i++)
    if(container[i]==value) return i;
  return -1;
}
string doubleToString(double d)
{
  std::ostringstream os;
  if(os<<d) return os.str();
  return "Error";
}

/*initialization functions:*/
void DrlRouting::init()
{
  addPathsFromFile();
  initNodes();
  initPaths();
  initAddrs();
  initRoute();
  //initSinks();
}
void DrlRouting::addPathsFromFile()
{
  if(printEnable) std::cout<<"addPathFromFile()"<<std::endl;
  std::ifstream in(inputPath.c_str());
  if(!in.is_open()){
    std::cout<<"Error opening file"<<std::endl;
    exit(1);
  }
  char buffer[500];
  vector<vector<int>> res;
  in.getline(buffer, 500);
  string cap(buffer);
  cap.append("Mbps");//link capacity
  while(!in.eof()){
    in.getline(buffer, 500);
    if(strcmp(buffer, "succeed")==0) break;//"succeed" means the end of paths
    if(strcmp(buffer, "fail")==0){
      cout<<"file information error!!!"<<endl;
      exit(1);
    }
    string str(buffer);
    vector<int> vec;
    unsigned int start=0;
    unsigned int pos=0;
    do{
      pos=str.find_first_of(',', start);//search the first ',' from start and return the index of ','
      int num=atoi(str.substr(start, pos-start).c_str());
      vec.push_back(num);
      start=pos+1;
    }while(pos<500);
    res.push_back(vec);
  }
  in.getline(buffer, 500);//send rates of the sessions
  in.close();
  string str(buffer);
  if(printEnable) std::cout<<"succeed:"<<str<<std::endl;
  vector<string> v_sendRate;
  unsigned int start=0;
  unsigned int end=0;
  while(end<str.size()){
    end=str.find_first_of(',', start);
    v_sendRate.push_back(str.substr(start, end-start).append("Mbps"));
    start=end+1;
  }
  setSendRate(v_sendRate);//set sendRates in DrlRouting
  setCap(cap);//set cap in DrlRouting
  for(unsigned int i=0; i<res.size(); i++){//init sPaths and sRatios
      addPath(res[i], 0);
  }
  meanRatio();//init sRatios by splitting evenly, i.e. 1.0/pathNum
  if(printEnable) std::cout<<"done"<<std::endl;
}
void DrlRouting::addPath(vector<int> pPath_, double ratio_)//init sPaths and sRatios
{
  int size=pPath_.size();
  if(size<2) return;//if path length is 1, return directly
  vector<int> path_;
  for(int i=0; i<size; i++) path_.push_back(pPath_[i]);
  int iSrc=path_[0];
  int iEnd=path_[size-2];//why size-2?? The last node is host!!!
  for(unsigned int i=0; i<sPaths.size(); i++){
    int pathNum_=sPaths[i].size();
    for(int j=0; j<pathNum_; j++){
      int nodeNum_=sPaths[i][j].size();
      if(sPaths[i][j][0]==iSrc && sPaths[i][j][nodeNum_-2]==iEnd){
        sPaths[i].push_back(path_);
        sRatios[i].push_back(ratio_);
        return;
      }
    }
  }
  vector<vector<int>> sPath;
  sPath.push_back(path_);
  sPaths.push_back(sPath);
  vector<double> sRatio;
  sRatio.push_back(ratio_);
  sRatios.push_back(sRatio);
}
void DrlRouting::initNodes()
{
  int maxNodei=0;//maximum node  id
  sessionNum=sPaths.size();
  pathNum=0;
  for(int i=0; i<sessionNum; i++)
    for(unsigned int j=0; j<sPaths[i].size(); j++){
      pathNum++;
      for(unsigned int k=0; k<sPaths[i][j].size(); k++)
        if(sPaths[i][j][k]>maxNodei) maxNodei=sPaths[i][j][k];
    }
  nodeNum=maxNodei+1;
  for(int i=0;i<nodeNum;i++){
    Ptr<Node> node=CreateObject<Node>();//create node
    nodes.Add(node);
  }
  internet.Install(nodes);//install protocol stack
  return;
}

void DrlRouting::initPaths()
{
  if(printEnable) cout<<"initPaths()"<<endl;
  p2p.SetDeviceAttribute("DataRate", DataRateValue(cap));//set link attributes
  p2p.SetChannelAttribute("Delay", StringValue("1ms"));

  errModel=CreateObject<RateErrorModel>(); 
  errModel->SetAttribute("ErrorRate", DoubleValue(err_p));//set error model of channel

  for(int i=0; i<sessionNum; i++){
    int pathNum_=sPaths[i].size();
    vector< vector<int> > sePaths;
    for(int j=0; j<pathNum_; j++){
      vector<int> pePaths;
      int stepNum_=sPaths[i][j].size()-1;
      for(int k=0; k<stepNum_; k++){
        int i1=sPaths[i][j][k];
        int i2=sPaths[i][j][k+1];
        int is=min(i1, i2);
        int ib=max(i1, i2);
        Edge edgePair(is, ib);
        int edgeNo=indexOf(edges, edgePair);
        int dir= i1<i2 ? 1 : -1;
        if(edgeNo>=0){
          pePaths.push_back((edgeNo+1)*dir);
          if(printEnable) cout<<"session:"<<i<<", path:"<<j<<", step:"<<k<<". edge:("<<i1<<"->"<<i2<<")="<<pePaths.back()<<endl;
          continue;
        }
        pePaths.push_back((edges.size()+1)*dir);
        if(printEnable) cout<<"session:"<<i<<", path:"<<j<<", step:"<<k<<". edge:("<<i1<<"->"<<i2<<")="<<pePaths.back()<<endl;
        edges.push_back(edgePair);
        Ptr<Node> n1=nodes.Get(is);
        Ptr<Node> n2=nodes.Get(ib);
        NodeContainer pair=NodeContainer(n1, n2);
        NetDeviceContainer step=p2p.Install(pair);
        step.Get(0)->SetAttribute("ReceiveErrorModel", PointerValue(errModel));
        step.Get(1)->SetAttribute("ReceiveErrorModel", PointerValue(errModel));
        spDevices.push_back(step);
      }
      sePaths.push_back(pePaths);
    }
    ePaths.push_back(sePaths);
  }
  return;
}

void DrlRouting::initAddrs()
{
  if(printEnable) cout<<"initAddrs()"<<endl;
  for(unsigned int i=0; i<spDevices.size(); i++){
    string addr=getAddr(i);
    ipv4.SetBase(addr.c_str(), "255.255.255.0");
    address.push_back(ipv4.Assign(spDevices[i]));
    if(printEnable) cout<<"edge "<<i<<" small node:"<<address.back().GetAddress(0)<<"big node:"<<address.back().GetAddress(1)<<endl;
  }
  return;
}

void DrlRouting::initRoute()
{
  if(printEnable) cout<<"initRoute()"<<endl;
  //vector<Edge> tempEdges;
  for(int i=0; i<nodeNum; i++){
    Ptr<Ipv4> ipv4Node=nodes.Get(i)->GetObject<Ipv4>();
    Ptr<Ipv4StaticRouting> srNode=srHelper.GetStaticRouting(ipv4Node);
    srNodes.push_back(srNode);
  }
  
  for(int i=0; i<sessionNum; i++)
  {
    int pathNum_=sPaths[i].size();
    vector<Ptr<Socket>> srcSocks;
    vector<Ptr<Socket>> endSocks;
    vector<Ptr<NetDevice>> srcDevs;
    vector<Ptr<NetDevice>> endDevs;
    for(int j=0; j<pathNum_; j++){
      int stepNum_=sPaths[i][j].size()-1;
      Ipv4Address addrEnd=address[spsToEdge(i, j, stepNum_-1)].GetAddress(spsEnd(i, j, stepNum_-1)-1);//destination address
      Ipv4Address addrSrc=address[spsToEdge(i, j, 0)].GetAddress(spsSrc(i, j, 0)-1);//source address
      int iSrc=sPaths[i][j][0];//source node
      int iEnd=sPaths[i][j].back();//destination node
      for(int k=0; k<stepNum_; k++){
        int nodei=sPaths[i][j][k];
        int nodeiNext=sPaths[i][j][k+1];
        //int is=min(nodei, nodeiNext);
        //int ib=max(nodei, nodeiNext);
        //Edge edgePair(is, ib);
        //tempEdges.push_back(edgePair);
        Ptr<Ipv4> ipv4Node=nodes.Get(nodei)->GetObject<Ipv4>();
        Ptr<Ipv4> ipv4NodeNext=nodes.Get(nodeiNext)->GetObject<Ipv4>();
        Ipv4Address addr=address[spsToEdge(i, j, k)].GetAddress(spsSrc(i, j, k)-1);
        Ipv4Address addrNext=address[spsToEdge(i, j, k)].GetAddress(spsEnd(i, j, k)-1);
        int itf=ipv4Node->GetInterfaceForAddress(addr);
        int itfNext=ipv4NodeNext->GetInterfaceForAddress(addrNext);
        if(printEnable) cout<<"addrSrc:"<<addrSrc<<", end addr:"<<addrEnd<<", cur addr:"<<addr<<", next hop:"<<addrNext<<endl;
        srNodes[nodei]->AddHostRouteTo(addrEnd, addrNext, itf);//paras:destination address;	next hop address; interface index; Metric of route in case of multiple routes to same destination
        srNodes[nodeiNext]->AddHostRouteTo(addrSrc, addr, itfNext);
      }
      //*********************************************************************
      //error hear
      //*********************************************************************
      Ptr<Socket> srcSock=Socket::CreateSocket(nodes.Get(iSrc), TypeId::LookupByName("ns3::UdpSocketFactory"));
      Ptr<Socket> endSock=Socket::CreateSocket(nodes.Get(iEnd), TypeId::LookupByName("ns3::UdpSocketFactory"));
      Ptr<NetDevice> srcDev=spDevices[spsToEdge(i, j, 0)].Get(spsSrc(i, j, 0)-1);
      Ptr<NetDevice> endDev=spDevices[spsToEdge(i, j, stepNum_-1)].Get(spsEnd(i, j, stepNum_-1)-1);
      InetSocketAddress beg=InetSocketAddress(addrSrc, ++port);
      srcSock->Bind(beg);
      InetSocketAddress dst=InetSocketAddress(addrEnd, port);
      endSock->Bind(dst);
      endSock->SetRecvCallback(MakeCallback(&recvCallback));//call a function when recieving a packet
      int res1=srcSock->Connect(dst);
      int res2=endSock->Connect(beg);
      Address addr1, addr2, addr3, addr4;//???????
      srcSock->GetSockName(addr1);
      srcSock->GetPeerName(addr2);
      endSock->GetSockName(addr3);
      endSock->GetPeerName(addr4);
      if(printEnable) cout<<"session "<<i<<" connected:"<<res1<<","<<res2<<", from "<<addr1<<" to "<<addr2<<", from "<<addr3<<" to "<<addr4<<endl;
      myTag tag;
      Ptr<Packet> packet=Create<Packet>(1024);
      Simulator::Schedule(Seconds(1.0), &UdpSend, srcSock, packet, i, j);//???????
      //Simulator::Schedule(Seconds(2.0), &UdpSend, endSock, packet->Copy(), i, j);
      srcSocks.push_back(srcSock);
      endSocks.push_back(endSock);
      srcDevs.push_back(srcDev);
      endDevs.push_back(endDev);
    }
    endsSocks.push_back(endSocks);
    srcsSocks.push_back(srcSocks);
    srcsDevs.push_back(srcDevs);
    endsDevs.push_back(endDevs);
  }
  return;
}
void DrlRouting::initSinks()
{
  PacketSinkHelper sink("ns3::UdpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), port));
  vector<unsigned int> flag;
  for(int i=0; i<nodeNum; i++){
    flag.push_back(0);
  }
  for(int i=0; i<sessionNum; i++){
    unsigned int pathNum_ = sPaths[i].size();
    for(unsigned int j=0; j<pathNum_; j++){
      int iEnd=sPaths[i][j].back();
      if(flag[iEnd]==1) continue;//if the node has been installed a sink, just ignore it
      ApplicationContainer app=sink.Install(nodes.Get(iEnd));
      app.Start(Seconds(0.0));
      sinkApps.push_back(app);
      flag[iEnd]=1;
    }
  }/*
  for(int i=0; i<sessionNum; i++){
    int iEnd=sPaths[i][0].back();
    for(int j=0; j<i; j++) if(sPaths[j][0].back()==iEnd) continue;//if the node has been installed a sink, just ignore it
    ApplicationContainer app=sink.Install(nodes.Get(iEnd));
    app.Start(Seconds(0.0));
    sinkApps.push_back(app);
  }*/
}
/*scheduling functions*/
void DrlRouting::begin()
{
  std::ofstream file;
  file.open(outputPath.c_str(), ios::trunc);//if the file has already existed, then delete it
  if(file) file.close();
  lastSec=Simulator::Now().GetSeconds();
  for(int i=0; i<sessionNum; i++){
    for(unsigned int j=0; j<sPaths[i].size(); j++){
      endsSocks[i][j]->thrs.clear();
      endsSocks[i][j]->dels.clear();
    }
    Simulator::ScheduleNow(&DrlRouting::randSendData, this, i, data, 65536);
    if(printEnable) cout<<"begin(), time:"<<lastSec<<endl;
  }
}

void DrlRouting::randSendData(int iSession, uint8_t *data, int size)//size is the total amount in this round
{
  Ptr<ExponentialRandomVariable> ExpDstrib=CreateObject<ExponentialRandomVariable>();
  Ptr<UniformRandomVariable> UniDstrib=CreateObject<UniformRandomVariable>();
  

  double time=Simulator::Now().GetSeconds();
  int realPacSize=std::min(size, packetSize);//get packet size
  Ptr<Packet> packet=Create<Packet>(data, realPacSize);
  int iPath=getRand(sRatios[iSession]);
  //int min=this->sendRates[0].GetBitRate()/1000000;
  //int max=this->sendRates[1].GetBitRate()/1000000;
  //if(min>max){min=min-max; max=max+min; min=max-min;}
  //double dataRate_mb=UniDstrib->GetInteger(min, max);
  if(printEnable2) std::cout<<"randSend, packet size:"<<realPacSize<<endl;
  double dataRate_mb=sendRates[iSession].GetBitRate()/1000000;
  //  double dataRate_kb=sendRates[iSession].GetBitRate()/1000;
  if(dataRate_mb==0) return;
  double micros=(double)realPacSize*8/dataRate_mb;

  // Todo Test
  int ns=micros*1000;
  ns=ExpDstrib->GetInteger(ns, ns*1.2);//??????
  micros=(double)ns/1000.0;
  
  
  Time tNext(MicroSeconds(micros));
  Simulator::ScheduleNow(&UdpSend, srcsSocks[iSession][iPath], packet, iSession, iPath);
  if(time-lastSec>=upTime/1000){
    lastSec=time;
    update();
  }

  if(size-realPacSize>0){
    if(stopTime!=0 && Simulator::Now().GetSeconds()>stopTime) return;
    Simulator::Schedule(tNext, &DrlRouting::randSendData, this, iSession, data+realPacSize, size-realPacSize);
  }
  else{
    if(stopTime!=0 && Simulator::Now().GetSeconds()>stopTime) return;
    int newDataSize=ExpDstrib->GetInteger(minDataSize, maxDataSize);
    Time offTime(MilliSeconds(this->offTime));
    Simulator::Schedule(offTime, &DrlRouting::randSendData, this, iSession, this->data, newDataSize);
  }
  return;
}

void DrlRouting::update()
{
  upNum++;
  double time=Simulator::Now().GetSeconds();
  if(printEnable) std::cout<<"\n\nupdate(), time:"<<time<<std::endl;
  vector<vector<double>> spDels;
  vector<vector<double>> spThrs;
  vector<vector<int>> spPacNos;
  for(int i=0; i<sessionNum; i++){
    int pathNum=sPaths[i].size();
    vector<double> dels;
    vector<double> thrs;
    vector<int> pacNos;
    for(int j=0; j<pathNum; j++){
      double del=0;
      double thr=0;
      int pacNo=endsSocks[i][j]->dels.size();
      for(int k=0; k<pacNo; k++){
        double del_=endsSocks[i][j]->dels[k];
        if(del_<=0) {pacNo--; continue;}
        del+=del_;
        thr+=endsSocks[i][j]->thrs[k];
      }
      if(pacNo>0) del=del/(double)pacNo;
      thr=thr/upTime*1000*8;
      pacNos.push_back(pacNo);
      dels.push_back(del);
      thrs.push_back(thr);
      if(printEnable) cout<<"session:"<<i<<", path:"<<j<<", pacNo:"<<pacNo<<", thr:"<<thr<<", del:"<<del<<endl;
      endsSocks[i][j]->thrs.clear();
      endsSocks[i][j]->dels.clear();
    }
    spDels.push_back(dels);
    spThrs.push_back(thrs);
    spPacNos.push_back(pacNos);
  }

  saveToFile(spPacNos, spDels, spThrs);
  update(spPacNos, spDels, spThrs);
  //randRatio();
//  if(upNum%20==0) updateWindow();
}

void DrlRouting::update(vector<vector<int>> pacNos, vector<vector<double>> dels, vector<vector<double>> thrs)
{
  ;
  /*
  PyObject *pArgs, *pArg, *pRto, *pThr, *pDel, *pRet;
  int len=sRatios.size();
  pRto=PyTuple_New(len);
  for(int i=0; i<len; i++){
    int ilen=sRatios[i].size();
    PyObject *temp=PyTuple_New(ilen);
    for(int j=0; j<ilen; j++) PyTuple_SetItem(temp, j, PyFloat_FromDouble(sRatios[i][j]));
    PyTuple_SetItem(pRto, i, temp);
  }
  len=sessionNum;
  pThr=PyTuple_New(len);
  for(int i=0; i<len; i++){
    int thrSum=0;
    for(double thr: thrs[i]) thrSum+=thr;
    PyTuple_SetItem(pThr, i, PyFloat_FromDouble(thrSum));
  }
  pDel=PyTuple_New(len);
  for(int i=0; i<len; i++){
    double aveDel=0;
    int pathNum=dels[i].size();
    int pacSum=accumulate(pacNos[i].begin(), pacNos[i].end(), 0);
    for(int j=0; j<pathNum; j++) aveDel+=dels[i][j]*pacNos[i][j]/pacSum;
    PyTuple_SetItem(pDel, i, PyFloat_FromDouble(aveDel));
  }
  pArgs=PyTuple_New(3);
  PyTuple_SetItem(pArgs, 0, pRto); PyTuple_SetItem(pArgs, 1, pThr); PyTuple_SetItem(pArgs, 2, pDel);
  pArg=PyTuple_New(1);
  PyTuple_SetItem(pArg, 0, pArgs);
  pRet=PyObject_CallObject(pFunc, pArg);
  if(pRet!=NULL){
    Py_DECREF(pRet);
    int len=PyTuple_Size(pRet);
    if(len==pathNum){
      int pos=0;
      for(int i=0;i<sessionNum;i++)
        for(unsigned int j=0; j<sRatios[i].size(); j++) 
          sRatios[i][j]=PyFloat_AsDouble(PyTuple_GetItem(pRet, pos++));
      if(printEnable) printf("C++ call python succeeded.\n\n");
    }
    else printf("Python return parameters are invalid. %d, %d.\n\n", len, pathNum);
  }
  else{
    PyErr_Print();
    cout<<"Error, C++ call Python failed !!!"<<endl;
  }
  */
}

void DrlRouting::saveToFile(vector<vector<int>> pacNos, vector<vector<double>> dels, vector<vector<double>> thrs)
{
  double time=Simulator::Now().GetSeconds();
  if(stopTime>0 && stopTime-time<=upTime/1000*1) {
    if(printEnable) std::cout<<stopTime<<" "<<time<<' '<<upTime/1000*1<<endl;
    return;
  }
  if(printEnable) std::cout<<"saveToFile()"<<std::endl;
  std::fstream file;
  file.open(outputPath.c_str(), std::ios::app);
  if(!file){
    std::cout<<outputPath<<" can't open"<<std::endl;
    return;
  }
  vector<double> sesthr;
  vector<double> sesdel;
  vector<double> seslog;
  int sn=sessionNum;
  for(int i=0; i<sn; i++){
    int pn=sRatios[i].size();
    double thrSum=accumulate(thrs[i].begin(), thrs[i].end(), 0);
    int pacNoSum=accumulate(pacNos[i].begin(), pacNos[i].end(), 0);
    double delAve=0;
    if(pacNoSum>0) for(int j=0; j<pn; j++) delAve+=dels[i][j]*pacNos[i][j]/pacNoSum;
    if(printEnable) cout<<"session "<<i<<",thrSum:"<<thrSum<<", aveDel:"<<delAve<<endl;
    sesthr.push_back(thrSum);
    sesdel.push_back(delAve);
    if(thrSum>0 && delAve >0) seslog.push_back(log(thrSum)-log(delAve));
    else seslog.push_back(0);
  }
  file<<"--------------------------------------"<<std::endl;
  file<<"Time: "<<doubleToString(time)<<std::endl;
  file<<"Split Ratios: ";
  for(unsigned int i=0; i<sRatios.size(); i++)
    for(unsigned int j=0; j<sRatios[i].size(); j++) file<<doubleToString(sRatios[i][j])<<" ";
  file<<std::endl;
  file<<"Delays: ";
  for(unsigned int i=0; i<sesdel.size(); i++) file<<doubleToString(sesdel[i])<<" ";
  file<<std::endl;
  file<<"Throughputs: ";
  for(unsigned int i=0; i<sesthr.size(); i++) file<<doubleToString(sesthr[i])<<" ";
  file<<std::endl;
  file<<"Utility: ";
  for(unsigned int i=0; i<seslog.size(); i++) file<<doubleToString(seslog[i])<<" ";
  file<<"\n\n";
  
  file.close();
  return ;
}
void UdpSend(Ptr<Socket> sock, Ptr<Packet> packet, int sess, int path)
{
  myTag tag;
  tag.SetValue1(Simulator::Now().GetSeconds());
  tag.SetValue2(sess);
//  tag.SetValue3(path);
  packet->AddPacketTag(tag); 
  sock->Send(packet);
}
void recvCallback(Ptr<Socket> socket)
{
  Address address;
  Ptr<Packet> packet=socket->RecvFrom(address);
  myTag tag;
  packet->PeekPacketTag(tag);
  double sendTime=tag.GetValue1();
  double iSession=tag.GetValue2();
//  double iPath=tag.GetValue3();
  double recvTime=Simulator::Now().GetSeconds();
  double pacSize=packet->GetSize();
  socket->thrs.push_back(pacSize);
  socket->dels.push_back(recvTime-sendTime);
  Address sendaddr;
  Address recvaddr;
  socket->GetPeerName(sendaddr);
  socket->GetSockName(recvaddr);
  if(printEnable2) cout<<"recv callback, time:"<<recvTime<<", sendtime:"<<sendTime<<",packetsize:"<<pacSize<<", sender session:"<<iSession<<endl;
}


/*set value functions*/
void DrlRouting::setErrp(double err)
{
  err_p=err;
}
void DrlRouting::setPrintEnable(bool printEn)
{
  printEnable=printEn;
}
void DrlRouting::setInputPath(string path)
{
  inputPath=path;
}
void DrlRouting::setOutputPath(string path)
{
  outputPath=path;
}
void DrlRouting::setUpTime(int time)
{
  upTime=time;
}
void DrlRouting::setStopTime(int time)
{
  stopTime=time;
}
void DrlRouting::setPacketSize(int size)
{
  packetSize=size;
}
void DrlRouting::setCap(string rate)
{
  cap=DataRate(rate.c_str());
}
void DrlRouting::setSendRate(vector<string> rates)
{
  for(unsigned int i=0; i<rates.size(); i++){
    DataRate rate=DataRate(rates[i].c_str());
    sendRates.push_back(rate);
  }
}
void DrlRouting::meanRatio()
{
  int sn=sRatios.size();
  for(int i=0; i<sn; i++){
    int pn=sRatios[i].size();
    for(int j=0; j<pn; j++){
      sRatios[i][j]=1.0/(double)pn;
    }
  }
}

void DrlRouting::randRatio()
{
  int sn=sRatios.size();
  for(int i=0; i<sn; i++){
    int pn=sRatios[i].size();
    double sum=0;
    for(int j=0; j<pn; j++){
      sRatios[i][j]=getRand();
      sum+=sRatios[i][j];
    }
    for(int j=0; j<pn; j++) sRatios[i][j]=sRatios[i][j]/sum;
  }
}

/*my tag*/
TypeId myTag::GetTypeId(void)
{
  static TypeId tid=TypeId("ns3::myTag")
	.SetParent<Tag>()
	.AddConstructor<myTag>();
  return tid;
}

TypeId myTag::GetInstanceTypeId(void) const
{
  return GetTypeId();
}

uint32_t myTag::GetSerializedSize(void) const 
{
  return 16;
}

void myTag::Serialize(TagBuffer i) const 
{
  i.WriteDouble(tagValue1);
  i.WriteDouble(tagValue2);
  //i.WriteDouble(tagValue3);
}

void myTag::Deserialize(TagBuffer i) 
{
  tagValue1=i.ReadDouble();
  tagValue2=i.ReadDouble();
  //tagValue3=i.ReadDouble();
}

void myTag::Print(std::ostream &os) const 
{
//  os<<"tagvalue1="<<tagValue1<<", tagvalue2="<<tagValue2<<", tagValue3="<<tagValue3<<endl;
	os<<"tagvalue1="<<tagValue1<<", tagvalue2="<<tagValue2<<endl;
}

void myTag::SetValue1(double value) 
{
  tagValue1=value;
}

double myTag::GetValue1() 
{
  return tagValue1;
}

void myTag::SetValue2(double value)
{
  tagValue2=value;
}

double myTag::GetValue2()
{
  return tagValue2;
}
